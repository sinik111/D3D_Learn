1. 동적 트리 갱신 작업과정 중 Insert/Remove , Rotation 과정
- Insert/Remove: AABB가 많이 이동해서 비효율적인 트리가 되었을때 트리에서 떼어냈다가 다시 삽입하는 과정
- 상세 과정
	1. 이동한 객체의 리프 노드(A) 찾기(오브젝트 인덱스-리프 노드 인덱스 배열을 통해 찾음)
	2. 리프 노드(A) 제거
	3. 리프 노드(A)의 기존 형제는 부모의 부모에 직접 연결하고 이전 노드 제거
	4. 해당 위치부터 루트까지 올라가면서 AABB 크기 갱신
	5. 루트부터 시작해서 이동한 객체를 넣기 가장 적합한 위치 탐색(SAH, 표면적 휴리스틱)
	6. 적합한 리프 노드(B)에 도달하면 새로운 부모 노드(C) 만듦
	7. 기존 리프 노드(B)와 이동한 객체의 리프 노드(A)를 새로운 부모 노드(C)의 자식으로 연결함
	8. 새로운 부모 노드(C)를 기존 리프 노드(B)에 있던 자리에 넣음
	9. 루트까지 올라가면서 AABB 크기 갱신

- Rotation: 트리의 구조가 비효율적으로 됐을 때 노드를 삭제하지 않고 교체하는 과정
- 상세 과정
	1. Refit 중 루트까지 올라가는 중에 Rotation 시도함
	2. 자식이 둘 다 리프면 건너뜀. 자식 중 하나라도 내부 노드면 Rotation 시도
	3. 자식과 손자들이 위치 교체가 필요한지 확인(SAH)
	4. 교체되었으면 AABB 크기 갱신 후 루트까지 계속 Rotation 시도 진행


2. 공간분할(Quad/Octree)와 비교하여 BVH는 어떤 장단점, 상황에서의 유리함이 있는지
- 공간 분할: 공간을 먼저 균등하게 나누고 물체가 공간 안에 속함.
- BVH: 물체를 기준으로 그룹을 묶고 공간이 물체에 따라 변함.
- BVH의 장점
	- 움직이는 물체가 많을 때 물체가 경계를 넘어가면 Octree/Quadtree는 항상 정확한 위치에 다시 찾아 넣어줘야 하지만 BVH는 Refit만 해주면 됨.
	물론 품질이 나빠질 수 있으므로 다른 과정들도 필요함.
	- 물체가 드문드문 있을 때 Octree/Quadtree는 빈 공간도 노드로 관리해야하지만 BVH는 물체가 있는 곳에만 노드가 생성되므로 메모리를 아낄 수 있음.
	- 정해진 공간이 아니라 예측이 불가능한 공간에서 Octree/Quadtree는 정해둔 크기를 벗어나면 더 큰 공간을 새로 만들어서 그 공간의 자식으로 만들어야함.
	BVH는 공간이 물체에 따라 변하므로 문제 없음.
- BVH의 단점
	- 물체들이 뭉쳐 있으면 노드끼리 많이 겹쳐서 충돌 검사시 양쪽 노드를 다 검사해야하는 상황 생김. Octree/Quadtree는 노드끼리 겹침이 없음.

3. BVH가 응용 되어 사용되는 곳
- BVH는 빈 공간을 빠르게 스킵해야 하는 모든 곳에서 사용됨.
- 실시간 레이 트레이싱: 빛이 물체와 부딪히는지 검사할 때, 텅 빈 공간을 빠르게 건너뛰기 위해 사용됨.
- 물리엔진의 Broad Phase: 충돌 가능성이 있는 후보를 빠르게 추려낼 때 사용함.
- 절두체 컬링: 카메라 절두체 밖의 물체를 렌더링에서 제외할 때 BVH 노드 단위로 빠르게 걸러내기 위해 사용됨.
- 마우스 피킹: 화면상의 3D 물체를 마우스로 클릭할 때 어떤 물체가 선택되었는지 빠르게 찾기 위해 사용됨.